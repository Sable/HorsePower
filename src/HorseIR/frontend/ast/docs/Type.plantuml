@startuml

package horseIR::ast {
        class ASTNode << (A,#FF7700) Abstract >> {
              + std::size_t getNumChildren()
              + ASTNode::const_iterator childConstBegin()
              + ASTNode::const_iterator childConstEnd()
              + ASTNode* getChildAt(std::size_t)

              + antlr4::tree::ParseTree* getCST()
              + std::size_t getNumNodesRecursively()

              + {abstract} std::string toString()
              + {abstract} std::toTreeString()
        }

        class ASTNodeMemory {
              + void manage(ASTNode*)
        }

        class Type << (A,#FF7700) Abstract >> {
              + {abstract} Type::TypeClass getTypeClass()
              + {abstract} bool isGeneralizationOf(Type*)
              + {static}   Type* makeTypeASTNode(HorseIRParser::TypeContext*, ASTNodeMemory&)
        }
        ASTNode <|-- Type

        class ScalarType {
              + ScalarType(HorseIRParser::TypeCaseScalarContext*, ASTNodeMemory&)
              + Type::TypeClass getTypeClass()
              + bool isGeneralizationOf(Type*)
              + std::string toString()
              + std::string toTreeString()
              + ScalarType::ScalarClass getScalarClass()
        }
        Type <|-- ScalarType

        class WildcardType {
              + WildcardType(HorseIRParser::TypeCaseWildcardContext*, ASTNodeMemory&)
              + Type::TypeClass getTypeClass()
              + bool isGeneralizationOf(Type*)
              + std::string toString()
              + std::string toTreeString()
        }
        Type <|-- WildcardType

        class ListType {
              + ListType(HorseIRParser::TypeCaseListContext*, ASTNodeMemory&)
              + Type::TypeClass getTypeClass()
              + bool isGeneralizationOf(Type*)
              + std::string toString()
              + std::string toTreeString()
              + Type* getElementType()
        }
        Type <|-- ListType

        class DictionaryType {
              + DictionaryType(HorseIRParser::TypeCaseDictContext*, ASTNodeMemory&)
              + Type::TypeClass getTypeClass()
              + bool isGeneralizationOf(Type*)
              + std::string toString()
              + std::string toTreeString()
              + Type* getKeyType()
              + Type* getValueType()
        }
        Type <|-- DictionaryType

        class EnumerationType {
              + EnumerationType(HorseIRParser::TypeCaseEnumContext*, ASTNodeMemory&)
              + Type::TypeClass getTypeClass()
              + bool isGeneralizationOf(Type*)
              + std::string toString()
              + std::string toTreeString()
              + Type* getElementType()
        }
        Type <|-- EnumerationType

        class FunctionType {
              + FunctionType(HorseIRParser::TypeCaseFuncContext*, ASTNodeMemory&)
              + Type::TypeClass getTypeClass()
              + bool isGeneralizationOf(Type*)
              + std::string toString()
              + std::string toTreeString()
              + std::size_t getMinNumParameters()
              + bool isFlexable
              + Type* getReturnType()
              + std::vecotr<Type*> getParameterTypes()
        }
        Type <|-- FunctionType
}

@enduml
